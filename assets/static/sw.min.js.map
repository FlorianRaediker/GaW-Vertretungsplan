{"version":3,"file":"sw.min.js","sources":["sw.js"],"sourcesContent":["\n// the following is inspired by code from (https://github.com/plausible/analytics/blob/0089add5944177bd2352510236a09157dc9d16bf/tracker/src/plausible.js, MIT license)\n// the original code isn't designed to be used with SWs\n//var plausible_ignore = window.localStorage.plausible_ignore;  // TODO: localStorage is not supported by SW\nfunction plausible(eventName, options) {\n    const payload = {\n        n: eventName,\n        u: self.location.toString(),\n        d: \"gawvertretung.florian-raediker.de\",\n        r: null,\n        //w: 0\n    }\n    if (options && options.meta) {\n        payload.m = JSON.stringify(options.meta)\n    }\n    if (options && options.props) {\n        payload.p = JSON.stringify(options.props)\n    }\n    return fetch(\"https://plausible.io/api/event\", {\n        method: \"POST\",\n        headers: {\"Content-Type\": \"text/plain\"},\n        body: JSON.stringify(payload)\n    }).catch(reason => console.error(\"reporting error failed\", reason))\n}\n\nfunction reportError(error, event = null) {\n    console.error(\"reporting error\", error, event);\n    try {\n        let name = error.name;\n        let message = (event == null ? undefined : event.message) ||\n            error.message;\n        let description = error.description;  // non-standard Microsoft property\n        let number = error.number; // non-standard Microsoft property\n        let filename = (event == null ? undefined : event.filename) ||\n            error.fileName;  // error.fileName is non-standard Mozilla property\n        let lineno = (event == null ? undefined : event.lineno) ||\n            error.lineNumber;  // error.lineNumber is non-standard Mozilla property\n        let colno = (event == null ? undefined : event.colno) ||\n            error.columnNumber;  // error.columnNumber is non-standard Mozilla property\n        let stack = (event == null ? undefined : event.stack) ||\n            error.stack;  // error.stack is non-standard Mozilla property\n        plausible(\"JavaScript Error (Service Worker)\", {\n            props: {\n                [(name || \"Generic Error\") + \": \" + message]: stack + \" - \" + filename + \":\" + lineno + \":\" + colno +\n                \" \" + description + \" \" + number\n            }\n        });\n    } catch (e) {\n        console.error(\"reporting error failed\", e);\n    }\n}\n\nself.addEventListener(\"error\", e => reportError(e.error, e));  // e.error is experimental, according to MDN\nself.addEventListener(\"unhandledrejection\", e => reportError(e.reason));\n\n\nconst CACHE = \"gawvertretung-v1\";\n\nconst planPaths = [\n    \"/students/\",\n    \"/teachers/\"\n];\n\nconst assetsToCache = [\n    \"/assets/style/main.css\",\n    \"/assets/style/main-dark.css\",\n    \"/assets/style/substitutions.css\",\n    \"/assets/style/substitutions-dark.css\",\n    \"/assets/js/substitutions.min.js\",\n    \"/assets/js/dark-theme.min.js\",\n    \"/assets/js/timetables.min.js\",\n    \"/assets/ferien/script.min.js\",\n    \"/assets/ferien/style.css\",\n    //\"/assets/img/python-powered.min.svg\", // caching <object src=\"...\"> doesn't work: https://stackoverflow.com/questions/56854918/how-to-interact-with-an-svg-asset-in-an-offline-progressive-web-app\n    \"/favicon-32x32.png\",\n    \"/android-chrome-192x192.png\"\n];\n\nself.addEventListener(\"install\", event => {\n    event.waitUntil(\n        caches.open(CACHE).then(cache =>\n            Promise.all([\n                // assetsToCache are added to the cache as soon as they're requested by the page\n                // this way, url params for cache busting can be changed in HTML and don't need to be saved in assetsToCache\n                //cache.addAll(assetsToCache),\n                Promise.all(\n                    // for plans, save a response in cache that is not redirected\n                    planPaths.map(url => fetch(url+\"?all&sw\").then(r => cache.put(url, r)))\n                )\n            ])\n        )\n    );\n});\n\nself.addEventListener(\"activate\", event => {\n    event.waitUntil(\n        caches.open(CACHE).then(cache => {\n            cache.keys().then(keys =>\n                Promise.all(\n                    keys.map(request => {\n                        const url = new URL(request.url);\n                        if (!(assetsToCache.includes(url.pathname) || planPaths.includes(url.pathname))) {\n                            console.log(\"cache: delete old\", request);\n                            return cache.delete(request);\n                        }\n                    })\n                )\n            )\n        })\n    )\n})\n\n// from https://serviceworke.rs/strategy-network-or-cache_service-worker_doc.html (MIT license)\nself.addEventListener(\"fetch\", event => {\n    const url = new URL(event.request.url);\n    console.log(\"requested\", event.request.url, url.pathname);\n    if (url.pathname === \"/\") {\n        event.respondWith(Response.redirect(\"/students/\"))\n    } else if (planPaths.includes(url.pathname)) {\n        // network-then-cache because plans need to be up-to-date\n        event.respondWith(\n            new Promise((fulfill, reject) => {\n                // currently, using a timeout might not display the most recent substitutions\n                // more work is needed, especially with WebSocket connection in updates.js\n                /*const timeout = setTimeout(() => {\n                    console.log(\"timeout\", url.pathname);\n                    reject();\n                }, 1000);*/\n                console.log(\"fetching\", event.request);\n                fetch(event.request).then(response => {\n                    //clearTimeout(timeout);\n                    console.log(\"fetch successful\", event.request.url);\n                    fulfill(response.clone());\n                    // save this version of the plan in cache\n                    caches.open(CACHE).then(cache => cache.put(url.pathname, response));\n                }, reject);\n            }).catch(() =>\n                caches.open(CACHE).then(cache =>\n                    cache.match(url.pathname, {ignoreSearch: true}).then(matching => {\n                        if (matching)\n                            return matching\n                        else {\n                            console.log(\"no match for\", event.request);\n                            return Promise.reject(\"no-match\");\n                        }\n                    })\n                )\n            )\n        );\n    } else if (assetsToCache.includes(url.pathname)) {\n        // cache-then-network (and if network fails, use outdated item from cache)\n        // update cache if url params are different (cache busting)\n        event.respondWith(\n            new Promise(resolve =>\n                // check whether the exact requested URL (including params for cache busting!) exists\n                caches.open(CACHE).then(cache => cache.match(event.request).then(response => {\n                    if (response) {\n                        // an up-to-date item is in the cache\n                        console.log(\"cache has up-to-date response for\", event.request.url);\n                        resolve(response);\n                        return;\n                    }\n                    fetch(event.request).then(async response => {\n                        console.log(\"cache is missing up-to-date response, fetching for\", event.request.url);\n                        resolve(response.clone());\n\n                        // delete all items in the cache that have the same pathname - they're outdated because they\n                        // haven't got the same cache busting parameter\n                        await cache.delete(event.request, {ignoreSearch: true, ignoreVary: true}).then(value => console.log(\"deleted\", value, event.request.url));\n\n                        console.log(\"putting in cache:\", event.request.url);\n                        // save this new up-to-date version in the cache\n                        await cache.put(event.request, response);\n                    }).catch(() => {\n                        // fetch didn't work, must fall back to an outdated version from cache\n                        resolve(cache.match(event.request, {ignoreSearch: true, ignoreVary: true}));\n                    })\n                }))\n            )\n        )\n        /*new Promise((fulfill, reject) => {\n                // currently, using a timeout might not display the most recent substitutions\n                // more work is needed, especially with WebSocket connection in updates.js\n                /*const timeout = setTimeout(() => {\n                    console.log(\"timeout\", url.pathname);\n                    reject();\n                }, 1000);* /\n                console.log(\"fetching\", event.request);\n                fetch(event.request).then(response => {\n                    //clearTimeout(timeout);\n                    console.log(\"fetch successful\", event.request.url);\n                    fulfill(response.clone());\n                    if ((url.pathname !== \"/students/\" && url.pathname !== \"/teachers/\") || url.search !== \"\") {\n                        console.log(\"saving response in cache\", event.request.url);\n                        caches.open(CACHE).then(cache => cache.put(new Request(url.pathname), response))\n                    } else {\n                        console.log(\"not saving in cache\", event.request.url);\n                    }\n                }, reject);\n            }).catch(() => caches.open(CACHE)\n                .then(cache => cache.match(event.request, {ignoreSearch: true})\n                    .then(matching => {\n                        if (matching)\n                            return matching\n                        else {\n                            console.log(\"no match for\", event.request);\n                            return Promise.reject(\"no-match\");\n                        }\n                    }))));*/\n    } else {\n        console.log(\"not using SW for request\");\n    }\n});\n\nself.addEventListener(\"push\", async (event) => {\n    if (!event.data) {\n        event.waitUntil(Promise.all([\n                self.registration.showNotification(\"Neue Benachrichtigung\", {\n                    icon: \"android-chrome-512x512.png\",\n                    badge: \"monochrome-96x96.png\",\n                    lang: \"de\"\n                }),\n                plausible(\"Notification\", {props: {other: \"Received, but without Payload\"}})\n            ])\n        );\n        return;\n    }\n    const data = event.data.json();\n\n    if (data.type === \"generic_message\") {\n        event.waitUntil(\n            self.registration.showNotification(data.title, {\n                body: data.body || \"\",\n                icon: \"android-chrome-512x512.png\",\n                badge: \"monochrome-96x96.png\",\n                lang: \"de\",\n                data: {\n                    type: \"generic_message\"\n                }\n            })\n        );\n    } else {\n        //let timestamp = data[\"timestamp\"];\n        let plan_id = data[\"plan_id\"];\n\n        // merge all affected groups of previous notifications with the same plan id that are still open\n        let affectedGroups = data[\"affected_groups_by_day\"];\n        console.log(\"affectedGroups\", affectedGroups);\n        for (let day of Object.values(affectedGroups)) {\n            day[\"groups\"] = new Set(day[\"groups\"]);\n        }\n        let currentTimestamp = Date.now()/1000;  // current UTC timestamp in seconds\n        event.waitUntil(\n            self.registration.getNotifications().then(notifications => {\n                for (let n of notifications) {\n                    if (n.data && n.data.plan_id === plan_id) {\n                        for (let [expiryTime, day] of Object.entries(n.data.affected_groups_by_day)) {\n                            console.log(\"expiryTime, currentTimestamp:\", expiryTime, currentTimestamp);\n                            if (expiryTime > currentTimestamp) {\n                                console.log(\"add\", day[\"groups\"]);\n                                if (expiryTime in affectedGroups) {\n                                    console.log(\"already in affectedGroups\");\n                                    day[\"groups\"].forEach(g => affectedGroups[expiryTime][\"groups\"].add(g));\n                                }\n                                else {\n                                    console.log(\"new day\", day);\n                                    affectedGroups[expiryTime] = day;\n                                }\n                            }\n                        }\n                        n.close();\n                    }\n                }\n                for (let day of Object.values(affectedGroups)) {\n                    day[\"groups\"] = Array.from(day[\"groups\"]);\n                }\n\n                let title;\n                let body;\n\n                if (Object.keys(affectedGroups).length === 1) {\n                    // there is only one day with new substitutions\n                    let day = Object.values(affectedGroups)[0];\n                    title = day[\"name\"] + \": Neue Vertretungen\";\n                    body = day[\"groups\"].join(\", \");\n                } else {\n                    title = \"Neue Vertretungen\";\n                    body = \"\";\n                    for (let day of Object.values(affectedGroups)) {\n                        body += day[\"name\"] + \": \" + day[\"groups\"].join(\", \") + \"\\n\";\n                    }\n                }\n\n                const options = {\n                    body: body,\n                    icon: \"android-chrome-512x512.png\",\n                    badge: \"monochrome-96x96.png\",\n                    lang: \"de\",\n                    //timestamp: timestamp,\n                    vibrate: [300, 100, 400],\n                    data: {\n                        type: \"subs_update\",\n                        plan_id: plan_id,\n                        url: new URL(\"/\" + plan_id + \"/?source=Notification\", self.location.origin).href,\n                        affected_groups_by_day: affectedGroups,\n                    }\n                };\n\n                self.registration.showNotification(title, options)\n\n                plausible(\"Notification\", {props: {[plan_id]: \"Received\"}})\n            })\n        );\n    }\n});\n\nself.addEventListener(\"notificationclick\", event => {\n    event.notification.close();\n\n    if (event.notification.data.type === \"subs_update\") {\n        // open website\n        event.waitUntil(Promise.all([\n            self.clients.matchAll().then(function(clientList) {\n                const notificationURL = new URL(event.notification.data.url);\n                for (let client of clientList) {\n                    const url = new URL(client.url);\n                    if (url.origin + url.pathname === notificationURL.origin + notificationURL.pathname && \"focus\" in\n                        client)\n                        return client.focus();\n                }\n                if (self.clients.openWindow)\n                    return self.clients.openWindow(event.notification.data.url);\n            }),\n\n            // close all notifications\n            self.registration.getNotifications().then(notifications => {\n                notifications.forEach(n => {\n                    if (n.data != null && n.data.plan_id === event.notification.data.plan_id)\n                        n.close()\n                });\n            }),\n\n            plausible(\"Notification\", {props: {[event.notification.data.plan_id]: \"Clicked\"}})\n        ]));\n    }\n});\n"],"names":["plausible","eventName","options","payload","n","u","self","location","toString","d","r","meta","m","JSON","stringify","props","p","fetch","method","headers","Content-Type","body","catch","reason","console","error","reportError","event","name","message","undefined","description","number","filename","fileName","lineno","lineNumber","colno","columnNumber","stack","e","addEventListener","CACHE","planPaths","assetsToCache","waitUntil","caches","open","then","cache","Promise","all","map","url","put","keys","request","URL","includes","pathname","log","delete","respondWith","Response","redirect","fulfill","reject","response","clone","match","ignoreSearch","matching","resolve","ignoreVary","value","async","data","json","type","registration","showNotification","title","icon","badge","lang","plan_id","affectedGroups","day","Object","values","Set","currentTimestamp","Date","now","getNotifications","notifications","expiryTime","entries","affected_groups_by_day","forEach","g","add","close","Array","from","length","join","vibrate","origin","href","other","notification","clients","matchAll","clientList","client","notificationURL","focus","openWindow"],"mappings":"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"}