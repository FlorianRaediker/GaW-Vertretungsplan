{"version":3,"sources":["sw.js"],"names":["plausible","eventName","options","payload","n","u","self","location","toString","d","r","meta","m","JSON","stringify","props","p","fetch","method","headers","Content-Type","body","catch","reason","console","error","reportError","event","name","message","undefined","description","number","filename","fileName","lineno","lineNumber","colno","columnNumber","stack","e","addEventListener","CACHE","planPaths","assetsToCache","waitUntil","caches","open","then","cache","Promise","all","map","url","put","keys","request","URL","includes","pathname","log","delete","respondWith","Response","redirect","fulfill","reject","response","clone","match","ignoreSearch","matching","resolve","ignoreVary","value","async","data","json","type","registration","showNotification","title","icon","badge","lang","plan_id","affectedGroups","day","Object","values","Set","currentTimestamp","Date","now","getNotifications","notifications","expiryTime","entries","affected_groups_by_day","forEach","g","add","close","Array","from","length","join","vibrate","origin","href","other","notification","clients","matchAll","clientList","client","notificationURL","focus","openWindow"],"mappings":"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","file":"sw.min.js","sourcesContent":["\n/*\n * GaW-Vertretungsplan\n * Copyright (C) 2019-2021  Florian RÃ¤diker\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// the following is inspired by code from (https://github.com/plausible/analytics/blob/0089add5944177bd2352510236a09157dc9d16bf/tracker/src/plausible.js, MIT license)\n// the original code isn't designed to be used with SWs\n//var plausible_ignore = window.localStorage.plausible_ignore;  // TODO: localStorage is not supported by SW\nfunction plausible(eventName, options) {\n    const payload = {\n        n: eventName,\n        u: self.location.toString(),\n        d: \"gawvertretung.florian-raediker.de\",\n        r: null,\n        //w: 0\n    }\n    if (options && options.meta) {\n        payload.m = JSON.stringify(options.meta)\n    }\n    if (options && options.props) {\n        payload.p = JSON.stringify(options.props)\n    }\n    return fetch(\"https://plausible.io/api/event\", {\n        method: \"POST\",\n        headers: {\"Content-Type\": \"text/plain\"},\n        body: JSON.stringify(payload)\n    }).catch(reason => console.error(\"reporting error failed\", reason))\n}\n\nfunction reportError(error, event = null) {\n    console.error(\"reporting error\", error, event);\n    try {\n        let name = error.name;\n        let message = (event == null ? undefined : event.message) ||\n            error.message;\n        let description = error.description;  // non-standard Microsoft property\n        let number = error.number; // non-standard Microsoft property\n        let filename = (event == null ? undefined : event.filename) ||\n            error.fileName;  // error.fileName is non-standard Mozilla property\n        let lineno = (event == null ? undefined : event.lineno) ||\n            error.lineNumber;  // error.lineNumber is non-standard Mozilla property\n        let colno = (event == null ? undefined : event.colno) ||\n            error.columnNumber;  // error.columnNumber is non-standard Mozilla property\n        let stack = (event == null ? undefined : event.stack) ||\n            error.stack;  // error.stack is non-standard Mozilla property\n        plausible(\"JavaScript Error (Service Worker)\", {\n            props: {\n                [(name || \"Generic Error\") + \": \" + message]: stack + \" - \" + filename + \":\" + lineno + \":\" + colno +\n                \" \" + description + \" \" + number\n            }\n        });\n    } catch (e) {\n        console.error(\"reporting error failed\", e);\n    }\n}\n\nself.addEventListener(\"error\", e => reportError(e.error, e));  // e.error is experimental, according to MDN\nself.addEventListener(\"unhandledrejection\", e => reportError(e.reason));\n\n\nconst CACHE = \"gawvertretung-v1\";\n\nconst planPaths = [\n    \"/students/\",\n    \"/teachers/\"\n];\n\nconst assetsToCache = [\n    \"/assets/style/main.css\",\n    \"/assets/style/main-dark.css\",\n    \"/assets/style/substitutions.css\",\n    \"/assets/style/substitutions-dark.css\",\n    \"/assets/js/substitutions.min.js\",\n    \"/assets/js/dark-theme.min.js\",\n    \"/assets/js/timetables.min.js\",\n    \"/assets/ferien/script.min.js\",\n    \"/assets/ferien/style.css\",\n    //\"/assets/img/python-powered.min.svg\", // caching <object src=\"...\"> doesn't work: https://stackoverflow.com/questions/56854918/how-to-interact-with-an-svg-asset-in-an-offline-progressive-web-app\n    \"/favicon-32x32.png\",\n    \"/android-chrome-192x192.png\"\n];\n\nself.addEventListener(\"install\", event => {\n    event.waitUntil(\n        caches.open(CACHE).then(cache =>\n            Promise.all([\n                // assetsToCache are added to the cache as soon as they're requested by the page\n                // this way, url params for cache busting can be changed in HTML and don't need to be saved in assetsToCache\n                //cache.addAll(assetsToCache),\n                Promise.all(\n                    // for plans, save a response in cache that is not redirected\n                    planPaths.map(url => fetch(url+\"?all&sw\").then(r => cache.put(url, r)))\n                )\n            ])\n        )\n    );\n});\n\nself.addEventListener(\"activate\", event => {\n    event.waitUntil(\n        caches.open(CACHE).then(cache => {\n            cache.keys().then(keys =>\n                Promise.all(\n                    keys.map(request => {\n                        const url = new URL(request.url);\n                        if (!(assetsToCache.includes(url.pathname) || planPaths.includes(url.pathname))) {\n                            console.log(\"cache: delete old\", request);\n                            return cache.delete(request);\n                        }\n                    })\n                )\n            )\n        })\n    )\n})\n\n// from https://serviceworke.rs/strategy-network-or-cache_service-worker_doc.html (MIT license)\nself.addEventListener(\"fetch\", event => {\n    const url = new URL(event.request.url);\n    console.log(\"requested\", event.request.url, url.pathname);\n    if (url.pathname === \"/\") {\n        event.respondWith(Response.redirect(\"/students/\"))\n    } else if (planPaths.includes(url.pathname)) {\n        // network-then-cache because plans need to be up-to-date\n        event.respondWith(\n            new Promise((fulfill, reject) => {\n                // currently, using a timeout might not display the most recent substitutions\n                // more work is needed, especially with WebSocket connection in updates.js\n                /*const timeout = setTimeout(() => {\n                    console.log(\"timeout\", url.pathname);\n                    reject();\n                }, 1000);*/\n                console.log(\"fetching\", event.request);\n                fetch(event.request).then(response => {\n                    //clearTimeout(timeout);\n                    console.log(\"fetch successful\", event.request.url);\n                    fulfill(response.clone());\n                    // save this version of the plan in cache\n                    caches.open(CACHE).then(cache => cache.put(url.pathname, response));\n                }, reject);\n            }).catch(() =>\n                caches.open(CACHE).then(cache =>\n                    cache.match(url.pathname, {ignoreSearch: true}).then(matching => {\n                        if (matching)\n                            return matching\n                        else {\n                            console.log(\"no match for\", event.request);\n                            return Promise.reject(\"no-match\");\n                        }\n                    })\n                )\n            )\n        );\n    } else if (assetsToCache.includes(url.pathname)) {\n        // cache-then-network (and if network fails, use outdated item from cache)\n        // update cache if url params are different (cache busting)\n        event.respondWith(\n            new Promise(resolve =>\n                // check whether the exact requested URL (including params for cache busting!) exists\n                caches.open(CACHE).then(cache => cache.match(event.request).then(response => {\n                    if (response) {\n                        // an up-to-date item is in the cache\n                        console.log(\"cache has up-to-date response for\", event.request.url);\n                        resolve(response);\n                        return;\n                    }\n                    fetch(event.request).then(async response => {\n                        console.log(\"cache is missing up-to-date response, fetching for\", event.request.url);\n                        resolve(response.clone());\n\n                        // delete all items in the cache that have the same pathname - they're outdated because they\n                        // haven't got the same cache busting parameter\n                        await cache.delete(event.request, {ignoreSearch: true, ignoreVary: true}).then(value => console.log(\"deleted\", value, event.request.url));\n\n                        console.log(\"putting in cache:\", event.request.url);\n                        // save this new up-to-date version in the cache\n                        await cache.put(event.request, response);\n                    }).catch(() => {\n                        // fetch didn't work, must fall back to an outdated version from cache\n                        resolve(cache.match(event.request, {ignoreSearch: true, ignoreVary: true}));\n                    })\n                }))\n            )\n        )\n        /*new Promise((fulfill, reject) => {\n                // currently, using a timeout might not display the most recent substitutions\n                // more work is needed, especially with WebSocket connection in updates.js\n                /*const timeout = setTimeout(() => {\n                    console.log(\"timeout\", url.pathname);\n                    reject();\n                }, 1000);* /\n                console.log(\"fetching\", event.request);\n                fetch(event.request).then(response => {\n                    //clearTimeout(timeout);\n                    console.log(\"fetch successful\", event.request.url);\n                    fulfill(response.clone());\n                    if ((url.pathname !== \"/students/\" && url.pathname !== \"/teachers/\") || url.search !== \"\") {\n                        console.log(\"saving response in cache\", event.request.url);\n                        caches.open(CACHE).then(cache => cache.put(new Request(url.pathname), response))\n                    } else {\n                        console.log(\"not saving in cache\", event.request.url);\n                    }\n                }, reject);\n            }).catch(() => caches.open(CACHE)\n                .then(cache => cache.match(event.request, {ignoreSearch: true})\n                    .then(matching => {\n                        if (matching)\n                            return matching\n                        else {\n                            console.log(\"no match for\", event.request);\n                            return Promise.reject(\"no-match\");\n                        }\n                    }))));*/\n    } else {\n        console.log(\"not using SW for request\");\n    }\n});\n\nself.addEventListener(\"push\", async (event) => {\n    if (!event.data) {\n        event.waitUntil(Promise.all([\n                self.registration.showNotification(\"Neue Benachrichtigung\", {\n                    icon: \"android-chrome-512x512.png\",\n                    badge: \"monochrome-96x96.png\",\n                    lang: \"de\"\n                }),\n                plausible(\"Notification\", {props: {other: \"Received, but without Payload\"}})\n            ])\n        );\n        return;\n    }\n    const data = event.data.json();\n\n    if (data.type === \"generic_message\") {\n        event.waitUntil(\n            self.registration.showNotification(data.title, {\n                body: data.body || \"\",\n                icon: \"android-chrome-512x512.png\",\n                badge: \"monochrome-96x96.png\",\n                lang: \"de\",\n                data: {\n                    type: \"generic_message\"\n                }\n            })\n        );\n    } else {\n        //let timestamp = data[\"timestamp\"];\n        let plan_id = data[\"plan_id\"];\n\n        // merge all affected groups of previous notifications with the same plan id that are still open\n        let affectedGroups = data[\"affected_groups_by_day\"];\n        console.log(\"affectedGroups\", affectedGroups);\n        for (let day of Object.values(affectedGroups)) {\n            day[\"groups\"] = new Set(day[\"groups\"]);\n        }\n        let currentTimestamp = Date.now()/1000;  // current UTC timestamp in seconds\n        event.waitUntil(\n            self.registration.getNotifications().then(notifications => {\n                for (let n of notifications) {\n                    if (n.data && n.data.plan_id === plan_id) {\n                        for (let [expiryTime, day] of Object.entries(n.data.affected_groups_by_day)) {\n                            console.log(\"expiryTime, currentTimestamp:\", expiryTime, currentTimestamp);\n                            if (expiryTime > currentTimestamp) {\n                                console.log(\"add\", day[\"groups\"]);\n                                if (expiryTime in affectedGroups) {\n                                    console.log(\"already in affectedGroups\");\n                                    day[\"groups\"].forEach(g => affectedGroups[expiryTime][\"groups\"].add(g));\n                                }\n                                else {\n                                    console.log(\"new day\", day);\n                                    affectedGroups[expiryTime] = day;\n                                }\n                            }\n                        }\n                        n.close();\n                    }\n                }\n                for (let day of Object.values(affectedGroups)) {\n                    day[\"groups\"] = Array.from(day[\"groups\"]);\n                }\n\n                let title;\n                let body;\n\n                if (Object.keys(affectedGroups).length === 1) {\n                    // there is only one day with new substitutions\n                    let day = Object.values(affectedGroups)[0];\n                    title = day[\"name\"] + \": Neue Vertretungen\";\n                    body = day[\"groups\"].join(\", \");\n                } else {\n                    title = \"Neue Vertretungen\";\n                    body = \"\";\n                    for (let day of Object.values(affectedGroups)) {\n                        body += day[\"name\"] + \": \" + day[\"groups\"].join(\", \") + \"\\n\";\n                    }\n                }\n\n                const options = {\n                    body: body,\n                    icon: \"android-chrome-512x512.png\",\n                    badge: \"monochrome-96x96.png\",\n                    lang: \"de\",\n                    //timestamp: timestamp,\n                    vibrate: [300, 100, 400],\n                    data: {\n                        type: \"subs_update\",\n                        plan_id: plan_id,\n                        url: new URL(\"/\" + plan_id + \"/?source=Notification\", self.location.origin).href,\n                        affected_groups_by_day: affectedGroups,\n                    }\n                };\n\n                self.registration.showNotification(title, options)\n\n                plausible(\"Notification\", {props: {[plan_id]: \"Received\"}})\n            })\n        );\n    }\n});\n\nself.addEventListener(\"notificationclick\", event => {\n    event.notification.close();\n\n    if (event.notification.data.type === \"subs_update\") {\n        // open website\n        event.waitUntil(Promise.all([\n            self.clients.matchAll().then(function(clientList) {\n                const notificationURL = new URL(event.notification.data.url);\n                for (let client of clientList) {\n                    const url = new URL(client.url);\n                    if (url.origin + url.pathname === notificationURL.origin + notificationURL.pathname && \"focus\" in\n                        client)\n                        return client.focus();\n                }\n                if (self.clients.openWindow)\n                    return self.clients.openWindow(event.notification.data.url);\n            }),\n\n            // close all notifications\n            self.registration.getNotifications().then(notifications => {\n                notifications.forEach(n => {\n                    if (n.data != null && n.data.plan_id === event.notification.data.plan_id)\n                        n.close()\n                });\n            }),\n\n            plausible(\"Notification\", {props: {[event.notification.data.plan_id]: \"Clicked\"}})\n        ]));\n    }\n});\n"]}